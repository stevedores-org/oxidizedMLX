#!/usr/bin/env bash
# lci — Local CI runner for oxidizedMLX
#
# Mirrors the GitHub Actions CI pipeline locally with file-hash caching.
# Stages that haven't changed since the last successful run are skipped.
#
# Usage:
#   ./tools/lci/lci              # run all stages (fmt, clippy, test)
#   ./tools/lci/lci --no-cache   # force all stages to run
#   ./tools/lci/lci --stage fmt  # run only the fmt stage
#   ./tools/lci/lci --ffi        # include mlx-sys (requires MLX_SRC)
#
# Ported from lornu.ai/tools/lci (Go).

set -euo pipefail

# ── Colors ──────────────────────────────────────────────────────────────

BOLD='\033[1m'
DIM='\033[2m'
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
RESET='\033[0m'

# Disable colors if not a terminal
if [[ ! -t 1 ]]; then
    BOLD="" DIM="" GREEN="" RED="" YELLOW="" CYAN="" RESET=""
fi

# ── Workspace root detection ────────────────────────────────────────────

find_workspace_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/Cargo.toml" ]] && grep -q '^\[workspace\]' "$dir/Cargo.toml" 2>/dev/null; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "Error: not inside a Cargo workspace" >&2
    return 1
}

WORKSPACE_ROOT="$(find_workspace_root)"
CACHE_FILE="$WORKSPACE_ROOT/.lci-cache.json"

# ── CLI flags ───────────────────────────────────────────────────────────

USE_CACHE=true
FFI_MODE=false
ONLY_STAGE=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-cache)  USE_CACHE=false; shift ;;
        --ffi)       FFI_MODE=true; shift ;;
        --stage)     ONLY_STAGE="$2"; shift 2 ;;
        -h|--help)
            echo "Usage: lci [--no-cache] [--ffi] [--stage STAGE]"
            echo ""
            echo "Stages: fmt, clippy, test"
            echo ""
            echo "Options:"
            echo "  --no-cache   Force all stages to run"
            echo "  --ffi        Include mlx-sys (requires MLX_SRC)"
            echo "  --stage S    Run only stage S"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# ── Source hash (git fast path) ─────────────────────────────────────────

compute_source_hash() {
    cd "$WORKSPACE_ROOT"
    # Fast path: use git if available and in a repo
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        # Hash of: tracked file content + staged changes + unstaged changes
        local tree_hash
        tree_hash="$(git write-tree 2>/dev/null || echo "")"
        local diff_hash
        diff_hash="$(git diff --no-ext-diff HEAD -- '*.rs' '*.toml' 2>/dev/null | sha256sum | cut -d' ' -f1)"
        echo "${tree_hash}:${diff_hash}" | sha256sum | cut -d' ' -f1
    else
        # Fallback: hash all .rs and .toml files
        find . -name target -prune -o \( -name '*.rs' -o -name '*.toml' \) -print0 \
            | sort -z \
            | xargs -0 sha256sum 2>/dev/null \
            | sha256sum \
            | cut -d' ' -f1
    fi
}

# ── Cache management ────────────────────────────────────────────────────

load_cached_hash() {
    local stage="$1"
    if [[ -f "$CACHE_FILE" ]] && command -v python3 &>/dev/null; then
        python3 -c "
import json, sys
try:
    d = json.load(open('$CACHE_FILE'))
    print(d.get('stages', {}).get('$stage', {}).get('hash', ''))
except: pass
" 2>/dev/null
    fi
}

save_cache() {
    local stage="$1" hash="$2"
    if command -v python3 &>/dev/null; then
        python3 -c "
import json, os, time
path = '$CACHE_FILE'
try:
    d = json.load(open(path))
except:
    d = {}
d.setdefault('stages', {})
d['stages']['$stage'] = {'hash': '$hash', 'timestamp': time.time()}
with open(path, 'w') as f:
    json.dump(d, f, indent=2)
" 2>/dev/null
    fi
}

# ── Environment checks ─────────────────────────────────────────────────

check_env() {
    local warnings=()

    if ! command -v cargo &>/dev/null; then
        echo -e "${RED}Error: cargo not found. Install Rust: https://rustup.rs${RESET}" >&2
        exit 1
    fi

    if command -v sccache &>/dev/null; then
        export RUSTC_WRAPPER=sccache
        echo -e "  ${DIM}sccache: enabled${RESET}"
    else
        warnings+=("sccache not found — builds will be slower")
    fi

    if $FFI_MODE && [[ -z "${MLX_SRC:-}" ]]; then
        echo -e "${RED}Error: --ffi requires MLX_SRC environment variable${RESET}" >&2
        exit 1
    fi

    for w in "${warnings[@]+"${warnings[@]}"}"; do
        echo -e "  ${YELLOW}⚠ $w${RESET}"
    done
}

# ── Stage runner ────────────────────────────────────────────────────────

# Results array: stage_name:status:duration_ms
declare -a RESULTS=()

run_stage() {
    local name="$1"
    shift
    local cmd=("$@")

    # Skip if not the requested stage
    if [[ -n "$ONLY_STAGE" && "$ONLY_STAGE" != "$name" ]]; then
        return 0
    fi

    local current_hash
    current_hash="$(compute_source_hash)"

    # Check cache
    if $USE_CACHE; then
        local cached_hash
        cached_hash="$(load_cached_hash "$name")"
        if [[ -n "$cached_hash" && "$cached_hash" == "$current_hash" ]]; then
            echo -e "${CYAN}  ⏭ ${name}${RESET} ${DIM}(cached — no changes)${RESET}"
            RESULTS+=("$name:skip:0")
            return 0
        fi
    fi

    echo -ne "${BOLD}  ▶ ${name}${RESET} "

    local start_ms
    start_ms=$(perl -MTime::HiRes=time -e 'printf "%d", time()*1000' 2>/dev/null || date +%s000)

    local log_file
    log_file=$(mktemp)

    if "${cmd[@]}" >"$log_file" 2>&1; then
        local end_ms
        end_ms=$(perl -MTime::HiRes=time -e 'printf "%d", time()*1000' 2>/dev/null || date +%s000)
        local dur_ms=$(( end_ms - start_ms ))
        echo -e "${GREEN}✓${RESET} ${DIM}(${dur_ms}ms)${RESET}"
        RESULTS+=("$name:pass:$dur_ms")
        # Update cache on success
        save_cache "$name" "$current_hash"
    else
        local end_ms
        end_ms=$(perl -MTime::HiRes=time -e 'printf "%d", time()*1000' 2>/dev/null || date +%s000)
        local dur_ms=$(( end_ms - start_ms ))
        echo -e "${RED}✗${RESET} ${DIM}(${dur_ms}ms)${RESET}"
        echo ""
        cat "$log_file"
        RESULTS+=("$name:fail:$dur_ms")
        rm -f "$log_file"
        return 1
    fi

    rm -f "$log_file"
}

# ── Summary table ───────────────────────────────────────────────────────

print_summary() {
    echo ""
    echo -e "${BOLD}  ┌─────────────┬────────┬───────────┐${RESET}"
    echo -e "${BOLD}  │ Stage       │ Status │ Duration  │${RESET}"
    echo -e "${BOLD}  ├─────────────┼────────┼───────────┤${RESET}"

    local any_fail=false
    for entry in "${RESULTS[@]}"; do
        IFS=':' read -r name status dur <<< "$entry"
        local status_str dur_str

        case "$status" in
            pass) status_str="${GREEN}PASS${RESET}"   ;;
            fail) status_str="${RED}FAIL${RESET}"; any_fail=true ;;
            skip) status_str="${YELLOW}SKIP${RESET}"  ;;
        esac

        if [[ "$dur" -eq 0 ]]; then
            dur_str="—"
        elif [[ "$dur" -lt 1000 ]]; then
            dur_str="${dur}ms"
        else
            dur_str="$(( dur / 1000 )).$(( (dur % 1000) / 100 ))s"
        fi

        printf "  │ %-11s │ %b │ %9s │\n" "$name" "$status_str" "$dur_str"
    done

    echo -e "${BOLD}  └─────────────┴────────┴───────────┘${RESET}"
    echo ""

    if $any_fail; then
        echo -e "  ${RED}${BOLD}Local CI failed.${RESET}"
        return 1
    else
        echo -e "  ${GREEN}${BOLD}Local CI passed.${RESET}"
    fi
}

# ── Main ────────────────────────────────────────────────────────────────

main() {
    echo ""
    echo -e "${BOLD}  oxidizedMLX Local CI${RESET}"
    echo -e "  ${DIM}─────────────────────${RESET}"

    check_env

    echo ""

    # Build exclude flags
    local exclude_flags=()
    if ! $FFI_MODE; then
        exclude_flags+=(--exclude mlx-sys)
    fi

    local failed=false

    run_stage "fmt" \
        cargo fmt --all --check \
        || failed=true

    if ! $failed; then
        run_stage "clippy" \
            cargo clippy --workspace "${exclude_flags[@]}" --all-targets -- -D warnings \
            || failed=true
    fi

    if ! $failed; then
        local test_excludes=("${exclude_flags[@]}")
        if ! $FFI_MODE; then
            test_excludes+=(--exclude mlx-conformance)
        fi
        run_stage "test" \
            cargo test --workspace "${test_excludes[@]}" \
            || failed=true
    fi

    print_summary || exit 1

    if $failed; then
        exit 1
    fi
}

main
